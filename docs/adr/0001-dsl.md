# 0001 – Introduce Orthogonal Task DSL

## Status

Accepted

## Context

The project previously described tasks using lightweight dictionaries.
This approach limited reuse and made it difficult to express complex
composable behavior.  The user requested a maximally orthogonal DSL where
each primitive contributes meaning without hidden dependencies. "Maximally
orthogonal" means every primitive adds exactly one semantic dimension and
its contribution is invariant across compositions.

## Decision

We replaced the prior task library with a typed DSL.  The DSL defines
independent primitives for data types, operations, and natural-language
specifications.  Composition operators combine primitives locally so the
meaning of a task emerges solely from immediate structure.

### Mapping to DSPy

| DSL construct | DSPy primitive |
| ------------- | -------------- |
| `Classify`    | `dspy.Predict` |
| `Map`         | `dspy.Module` wrapping elementwise calls |
| `Filter`      | `dspy.Module` applying predicate module |
| `Sequential`  | `dspy.Module` chaining submodules |
| `Parallel`    | `dspy.Module` returning tuple of submodules |
| `NaturalSpec` | `dspy.Predict` with free-form prompt |

Migration from dictionary tasks uses the `dict_to_spec` utility which wraps
existing dictionaries in `TaskSpec` records.

### Migration Path

Legacy definitions:

```python
old = {
    "description": "classify sentiment",
    "cases": ["'good'->'positive'"]
}
```

Convert to DSL:

```python
from mkspy.migrate import dict_to_spec

spec = dict_to_spec(old)
```

The helper preserves existing fields while enabling incremental refinement
with typed primitives and operations.

Acceptance criteria for orthogonality:

1. **Isolation** – each primitive is meaningful alone.
2. **Combination** – composing primitives yields predictable types.
3. **Substitution** – replacing a primitive affects only its own output.
4. **Decomposition** – complex specs can be inspected to recover parts.
5. **Novelty** – any well-typed combination requires no extra rules.

## Consequences

- Tasks are represented as `TaskSpec` records composed from primitives.
- The DSL supports predictable extension through new primitives or
  operators.
- Existing components such as `GEPAEvolver` now operate on structured
  `TaskSpec` instances.

- Type mismatches during composition raise `TypeError` explaining which
  primitives misaligned.

### Failure Modes

- Passing a non-`Composable` object to `task()` raises `TypeError`.
- Constructing `Sequential` or `Parallel` with mismatched types fails fast.
- Calling `to_module()` on a `TaskSpec` without a process returns `None`.
