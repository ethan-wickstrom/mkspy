from __future__ import annotations

from typing import Any

from .model import (
    DSPyProgram,
    DSPyImport,
    DSPySignature,
    DSPyField,
    DSPyClass,
    DSPyMethod,
    DSPyParameter,
    DSPyAssignment,
    DSPyReturn,
    DSPySignatureBinding,
)
from .validation import prune_unused_imports
from .codemod import codemod_ast_to_libcst


def _baseline_signature(requirements: str) -> DSPySignature:
    """Create a minimal signature using the requirements as docstring.

    Input: one field `text: str`. Output: one field `result: str`.
    """
    return DSPySignature(
        name="UserTask",
        docstring=requirements or "Program synthesis task.",
        inputs=[DSPyField("text", "str", "Task input text")],
        outputs=[DSPyField("result", "str", "Task output", is_input=False)],
    )


def _baseline_class() -> DSPyClass:
    """Create a minimal class with a forward that calls `self.solver`."""
    fwd = DSPyMethod(
        name="forward",
        parameters=[DSPyParameter("self"), DSPyParameter("text", "str")],
        return_type="dspy.Prediction",
        body=[
            DSPyAssignment("out", "self.solver(text=text)"),
            DSPyReturn("out"),
        ],
    )
    return DSPyClass(
        name="Program",
        docstring="Autogenerated DSPy program.",
        methods=[fwd],
    )


def generate_structured_code(requirements: str) -> str:
    """Synthesize a minimal, runnable DSPy program from requirements.

    - Builds a signature with the requirements as docstring.
    - Wires a `Predict(UserTask)` module to `self.solver`.
    - Adds a forward that calls the solver and returns its prediction.
    """
    p = DSPyProgram(
        imports=[
            DSPyImport(module="dspy"),
            DSPyImport(from_module="typing", imported_names=["Optional", "List", "Dict", "Any"]),
        ],
        signatures=[_baseline_signature(requirements)],
        main_class=_baseline_class(),
        bound_modules=[
            DSPySignatureBinding(
                module_name="solver",
                signature_name="UserTask",
                module_type="Predict",
                parameters={},
            )
        ],
        program_var="program",
    )
    code = p.to_code()
    # Best-effort cleanup
    code = prune_unused_imports(code)
    code = codemod_ast_to_libcst(code)
    return code


def postprocess_code(code: str) -> str:
    """Apply standard postprocessing (import pruning + codemod)."""
    return codemod_ast_to_libcst(prune_unused_imports(code))


def get_program_author(lm: Any | None = None) -> Any:
    """Return a DSPy Module that writes DSPy programs using tools.

    The returned module has signature: requirements -> source
    Tools used:
      - generate_structured_code(requirements) -> source
      - postprocess_code(source) -> source
    """
    import importlib

    dspy = importlib.import_module("dspy")

    class AuthorSig(dspy.Signature):
        """Write a valid Python DSPy program per user requirements."""
        requirements: str = dspy.InputField(desc="User's intent and constraints")
        source: str = dspy.OutputField(desc="Python code for a DSPy program")

    # Expose tools with informative docstrings for ReAct
    def _tool_generate(requirements: str) -> str:
        """generate_structured_code(requirements: str) -> str

        Build a minimal but runnable DSPy program matching the requirements.
        Returns Python source as a string.
        """
        return generate_structured_code(requirements)

    def _tool_postprocess(code: str) -> str:
        """postprocess_code(code: str) -> str

        Clean up imports and rewrite builtin `ast` usage to LibCST idioms.
        Returns the transformed Python source.
        """
        return postprocess_code(code)

    class ProgramAuthor(dspy.Module):
        def __init__(self):
            super().__init__()
            tools = [_tool_generate, _tool_postprocess]
            self.agent = dspy.ReAct(AuthorSig, tools=tools)
            if lm is not None:
                dspy.configure(lm=lm)

        def forward(self, requirements: str) -> Any:
            pred = self.agent(requirements=requirements)
            return dspy.Prediction(source=pred.source)

    return ProgramAuthor()


# -----------------------
# GEPA optimization setup
# -----------------------

def _score_generated_code(req: str, code: str) -> tuple[float, str]:
    """Heuristic structural scorer with natural language feedback.

    Criteria (sum to <= 1.0):
    - Parsable by LibCST (0.2)
    - Has `import dspy` (0.1)
    - Has a Signature subclass (0.2)
    - Has a Module subclass (0.2)
    - Has forward method (0.1)
    - Exports a program var (0.1)
    - Wires a DSPy module (Predict/CoT/ReAct) (0.1)
    """
    import libcst as cst

    score = 0.0
    notes: list[str] = []

    try:
        _ = cst.parse_module(code)
        score += 0.2
    except Exception as e:
        notes.append(f"Parse error: {e}")

    if "import dspy" in code:
        score += 0.1
    else:
        notes.append("Missing `import dspy`.")

    if "(dspy.Signature):" in code or "(dspy.Signature):" in code.replace(" ", ""):
        score += 0.2
    elif "class" in code and "Signature" in code:
        score += 0.1
        notes.append("Signature subclass found but shape uncertain.")
    else:
        notes.append("Missing `class <Name>(dspy.Signature)`.")

    if "(dspy.Module):" in code or "(dspy.Module):" in code.replace(" ", ""):
        score += 0.2
    else:
        notes.append("Missing `class <Name>(dspy.Module)`.")

    if "def forward(" in code:
        score += 0.1
    else:
        notes.append("Missing `def forward(...)`.")

    if "program = " in code and "()" in code:
        score += 0.1
    else:
        notes.append("Missing `program = <MainClass>()` export.")

    if any(k in code for k in ("dspy.Predict(", "dspy.ChainOfThought(", "dspy.ReAct(")):
        score += 0.1
    else:
        notes.append("No DSPy module constructed (Predict/ChainOfThought/ReAct).")

    msg = "OK" if not notes else "\n".join(notes)
    return min(score, 1.0), msg


def author_metric(example, prediction, trace=None, pred_name=None, pred_trace=None):
    """GEPA-compatible metric with natural-language feedback.

    Expects example.requirements and prediction.source (from ProgramAuthor).
    """
    req = getattr(example, "requirements", None) or getattr(example, "input", "")
    src = getattr(prediction, "source", "")
    score, feedback = _score_generated_code(str(req), str(src))
    return {"score": float(score), "feedback": feedback}


def _examples_from_requirements(reqs: list[str]):
    import importlib
    dspy = importlib.import_module("dspy")
    out = []
    for r in reqs:
        ex = dspy.Example(requirements=r).with_inputs("requirements")
        out.append(ex)
    return out


def default_author_trainset() -> list[Any]:
    reqs = [
        "Write a DSPy program that echoes input text to result.",
        "Create a DSPy program with a signature question->answer and a module that returns a prediction.",
        "Produce a minimal DSPy program exposing `program = <Main>()` with a forward method.",
        "Build a DSPy program that binds dspy.Predict to a signature and calls it in forward.",
    ]
    return _examples_from_requirements(reqs)


def optimize_program_author(
    *,
    trainset: list[Any] | None = None,
    valset: list[Any] | None = None,
    gen_model: Any | None = None,
    reflection_lm: Any | None = None,
    gepa_kwargs: dict[str, Any] | None = None,
):
    """Optimize the Author agent using GEPA and return the optimized module.

    - gen_model: dspy.LM used to run the author during eval
    - reflection_lm: dspy.LM used by GEPA to reflect and propose updates
    - gepa_kwargs: forwarded to GEPA (e.g., max_metric_calls, num_threads)
    """
    import importlib
    from dspy import GEPA  # noqa: F401

    dspy = importlib.import_module("dspy")

    if gen_model is not None:
        dspy.configure(lm=gen_model)

    student = get_program_author(lm=gen_model)

    tr = trainset or default_author_trainset()
    va = valset or tr

    if reflection_lm is None:
        raise ValueError("reflection_lm must be provided (e.g., dspy.LM('gpt-5', ...))")

    kw = dict(gepa_kwargs or {})
    kw.setdefault("max_metric_calls", 100)
    kw.setdefault("num_threads", 4)

    tele = dspy.GEPA(metric=author_metric, reflection_lm=reflection_lm, **kw)
    return tele.compile(student, trainset=tr, valset=va)
