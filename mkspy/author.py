from __future__ import annotations

from typing import Any

from dspy import Example, Prediction
from dspy.teleprompt.gepa.gepa_utils import DSPyTrace, ScoreWithFeedback

from .model import (
    DSPyProgram,
    DSPyImport,
    DSPySignature,
    DSPyField,
    DSPyClass,
    DSPyMethod,
    DSPyParameter,
    DSPyAssignment,
    DSPyReturn,
    DSPySignatureBinding,
)
from .validation import prune_unused_imports
from .cst_utils import score_program

# This module focuses on "authoring": synthesizing minimal DSPy programs,
# exposing a program authoring agent, and defining a GEPA-compatible metric.
# LibCST analysis lives in mkspy.cst_utils for orthogonality.


def _baseline_signature(requirements: str) -> DSPySignature:
    """Create a minimal signature using the requirements as docstring.

    Input: one field `text: str`. Output: one field `result: str`.
    """
    return DSPySignature(
        name="UserTask",
        docstring=requirements or "Program synthesis task.",
        inputs=[DSPyField("text", "str", "Task input text")],
        outputs=[DSPyField("result", "str", "Task output", is_input=False)],
    )


def _baseline_class() -> DSPyClass:
    """Create a minimal class with a forward that calls `self.solver`."""
    fwd = DSPyMethod(
        name="forward",
        parameters=[DSPyParameter("self"), DSPyParameter("text", "str")],
        return_type="dspy.Prediction",
        body=[
            DSPyAssignment("out", "self.solver(text=text)"),
            DSPyReturn("out"),
        ],
    )
    return DSPyClass(
        name="Program",
        docstring="Autogenerated DSPy program.",
        methods=[fwd],
    )


def generate_structured_code(requirements: str) -> str:
    """Synthesize a minimal, runnable DSPy program from requirements.

    - Builds a signature with the requirements as docstring.
    - Wires a `Predict(UserTask)` module to `self.solver`.
    - Adds a forward that calls the solver and returns its prediction.
    """
    p = DSPyProgram(
        imports=[
            DSPyImport(module="dspy"),
            DSPyImport(from_module="typing", imported_names=["Optional", "List", "Dict", "Any"]),
        ],
        signatures=[_baseline_signature(requirements)],
        main_class=_baseline_class(),
        bound_modules=[
            DSPySignatureBinding(
                module_name="solver",
                signature_name="UserTask",
                module_type="Predict",
                parameters={},
            )
        ],
        program_var="program",
    )
    code = p.to_code()
    # Best-effort cleanup
    code = prune_unused_imports(code)
    return code


def get_program_author(lm: Any | None = None) -> Any:
    """Return a DSPy Module that writes DSPy programs using tools.

    The returned module has signature: requirements -> source
    Tools used:
      - generate_structured_code(requirements) -> source
    """
    import importlib

    dspy = importlib.import_module("dspy")

    class AuthorSig(dspy.Signature):
        """Write a valid Python DSPy program per user requirements."""
        requirements: str = dspy.InputField(desc="User's intent and constraints")
        source: str = dspy.OutputField(desc="Python code for a DSPy program")

    # Expose tool with informative docstring for ReAct
    def _tool_generate(requirements: str) -> str:
        """generate_structured_code(requirements: str) -> str

        Build a minimal but runnable DSPy program matching the requirements.
        Returns Python source as a string.
        """
        return generate_structured_code(requirements)

    class ProgramAuthor(dspy.Module):
        def __init__(self):
            super().__init__()
            tools = [_tool_generate]
            self.agent = dspy.ReAct(AuthorSig, tools=tools)
            if lm is not None:
                dspy.configure(lm=lm)

        def forward(self, requirements: str) -> Any:
            pred = self.agent(requirements=requirements)
            return dspy.Prediction(source=pred.source)

    return ProgramAuthor()


def author_metric(
    example: Example,
    prediction: Prediction,
    trace: DSPyTrace | None = None,
    pred_name: str | None = None,
    pred_trace: DSPyTrace | None = None,
) -> ScoreWithFeedback:
    """GEPA-compatible metric with natural-language feedback.

    Expects ``example.requirements`` and ``prediction.source`` (from ProgramAuthor).
    Uses LibCST-based scoring to provide robust structure feedback.
    """
    _req: str = str(getattr(example, "requirements", None) or getattr(example, "input", ""))
    src: str = str(getattr(prediction, "source", ""))

    raw_score, feedback = score_program(src)
    return ScoreWithFeedback(score=float(raw_score), feedback=feedback)


def _examples_from_requirements(reqs: list[str]):
    import importlib
    dspy = importlib.import_module("dspy")
    out = []
    for r in reqs:
        ex = dspy.Example(requirements=r).with_inputs("requirements")
        out.append(ex)
    return out


def default_author_trainset() -> list[Any]:
    reqs = [
        # General code skeletons
        "Write a DSPy program that echoes input text to result.",
        "Produce a minimal DSPy program exposing `program = <Main>()` with a forward method.",
        "Build a DSPy program that binds dspy.Predict to a signature and calls it in forward.",
        # Two-stage reasoning patterns (domain-agnostic)
        "Create a two-stage solver: first reason step-by-step, then extract only the final answer.",
        # Non-math domains
        "Design a classifier signature text->label and return only the label in extract stage.",
        "Design an extractor signature record->fields and ensure extract returns a comma-separated list only.",
        "Design a QA signature question->answer where extract returns a short, direct answer only.",
    ]
    return _examples_from_requirements(reqs)


def optimize_program_author(
    *,
    trainset: list[Any] | None = None,
    valset: list[Any] | None = None,
    gen_model: Any | None = None,
    reflection_lm: Any | None = None,
    gepa_kwargs: dict[str, Any] | None = None,
):
    """Optimize the Author agent using GEPA and return the optimized module.

    - gen_model: dspy.LM used to run the author during eval
    - reflection_lm: dspy.LM used by GEPA to reflect and propose updates
    - gepa_kwargs: forwarded to GEPA (e.g., max_metric_calls, num_threads)
    """
    import importlib
    dspy = importlib.import_module("dspy")

    if gen_model is not None:
        dspy.configure(lm=gen_model)

    student = get_program_author(lm=gen_model)

    tr = trainset or default_author_trainset()
    va = valset or tr

    if reflection_lm is None:
        raise ValueError("reflection_lm must be provided (e.g., dspy.LM('gpt-5', ...))")

    kw = dict(gepa_kwargs or {})
    kw.setdefault("max_metric_calls", 100)
    kw.setdefault("num_threads", 4)

    tele = dspy.GEPA(metric=author_metric, reflection_lm=reflection_lm, **kw)
    return tele.compile(student, trainset=tr, valset=va)
