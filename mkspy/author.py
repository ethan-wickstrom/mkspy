from __future__ import annotations

from typing import Any

from .model import (
    DSPyProgram,
    DSPyImport,
    DSPySignature,
    DSPyField,
    DSPyClass,
    DSPyMethod,
    DSPyParameter,
    DSPyAssignment,
    DSPyReturn,
    DSPySignatureBinding,
)
from .validation import prune_unused_imports
from .codemod import codemod_ast_to_libcst


def _baseline_signature(requirements: str) -> DSPySignature:
    """Create a minimal signature using the requirements as docstring.

    Input: one field `text: str`. Output: one field `result: str`.
    """
    return DSPySignature(
        name="UserTask",
        docstring=requirements or "Program synthesis task.",
        inputs=[DSPyField("text", "str", "Task input text")],
        outputs=[DSPyField("result", "str", "Task output", is_input=False)],
    )


def _baseline_class() -> DSPyClass:
    """Create a minimal class with a forward that calls `self.solver`."""
    fwd = DSPyMethod(
        name="forward",
        parameters=[DSPyParameter("self"), DSPyParameter("text", "str")],
        return_type="dspy.Prediction",
        body=[
            DSPyAssignment("out", "self.solver(text=text)"),
            DSPyReturn("out"),
        ],
    )
    return DSPyClass(
        name="Program",
        docstring="Autogenerated DSPy program.",
        methods=[fwd],
    )


def generate_structured_code(requirements: str) -> str:
    """Synthesize a minimal, runnable DSPy program from requirements.

    - Builds a signature with the requirements as docstring.
    - Wires a `Predict(UserTask)` module to `self.solver`.
    - Adds a forward that calls the solver and returns its prediction.
    """
    p = DSPyProgram(
        imports=[
            DSPyImport(module="dspy"),
            DSPyImport(from_module="typing", imported_names=["Optional", "List", "Dict", "Any"]),
        ],
        signatures=[_baseline_signature(requirements)],
        main_class=_baseline_class(),
        bound_modules=[
            DSPySignatureBinding(
                module_name="solver",
                signature_name="UserTask",
                module_type="Predict",
                parameters={},
            )
        ],
        program_var="program",
    )
    code = p.to_code()
    # Best-effort cleanup
    code = prune_unused_imports(code)
    code = codemod_ast_to_libcst(code)
    return code


def postprocess_code(code: str) -> str:
    """Apply standard postprocessing (import pruning + codemod)."""
    return codemod_ast_to_libcst(prune_unused_imports(code))


def get_program_author(lm: Any | None = None) -> Any:
    """Return a DSPy Module that writes DSPy programs using tools.

    The returned module has signature: requirements -> source
    Tools used:
      - generate_structured_code(requirements) -> source
      - postprocess_code(source) -> source
    """
    import importlib

    dspy = importlib.import_module("dspy")

    class AuthorSig(dspy.Signature):
        """Write a valid Python DSPy program per user requirements."""
        requirements: str = dspy.InputField(desc="User's intent and constraints")
        source: str = dspy.OutputField(desc="Python code for a DSPy program")

    # Expose tools with informative docstrings for ReAct
    def _tool_generate(requirements: str) -> str:
        """generate_structured_code(requirements: str) -> str

        Build a minimal but runnable DSPy program matching the requirements.
        Returns Python source as a string.
        """
        return generate_structured_code(requirements)

    def _tool_postprocess(code: str) -> str:
        """postprocess_code(code: str) -> str

        Clean up imports and rewrite builtin `ast` usage to LibCST idioms.
        Returns the transformed Python source.
        """
        return postprocess_code(code)

    class ProgramAuthor(dspy.Module):
        def __init__(self):
            super().__init__()
            tools = [_tool_generate, _tool_postprocess]
            self.agent = dspy.ReAct(AuthorSig, tools=tools)
            if lm is not None:
                dspy.configure(lm=lm)

        def forward(self, requirements: str) -> Any:
            pred = self.agent(requirements=requirements)
            return dspy.Prediction(source=pred.source)

    return ProgramAuthor()

